
type AzuloTrustFactory @entity {
    # factory address
    id: ID!

    # total volume
    totalVolumeUSD: BigDecimal!
    totalVolumeETH: BigDecimal!

    # untracked values - less confident USD scores
    untrackedVolumeUSD: BigDecimal!

    # total assets
    totalAssetsUSD: BigDecimal!
    totalAssetsETH: BigDecimal!

    # transactions
    txCount: BigInt!
}

type AzuloTrustDaily @entity {
    id: ID! # timestamp rounded to current day by dividing by 86400
    date: Int!

    dailyVolumeETH: BigDecimal!
    dailyVolumeUSD: BigDecimal!
    dailyVolumeUntracked: BigDecimal!

    totalVolumeETH: BigDecimal!
    totalVolumeUSD: BigDecimal! # Accumulate at each trade, not just calculated off whatever totalVolume is. making it more accurate as it is a live conversion

    txCount: BigInt!
}

type Wallet @entity {
    "Unique identifier of the wallet (contract Address)"
    id                  : ID!

    "Address who created the contract"
    creator             : Bytes!

    "Network where the wallet is deployed (plain text: rinkeby, ropsten, mainnet, etc.)"
    network             : String!

    "Timestamp when the wallet was deployed"
    stamp               : BigInt!

    "Transaction hash when the wallet was deployed"
    hash                : Bytes!

    "Factory Address which deployed the wallet"
    factory             : Bytes!

    "List of owner Addresses of the wallet"
    owners              : [Bytes!]!

    "Number of confirmation required to execute a transaction out of the wallet"
    threshold           : BigInt!

    "List of successful and failed transactions executed from the wallet"
    transactions        : [Transaction!]!

    "Value of total assets held in USD"
    totalAssetsUSD: BigDecimal!

    "Value of total assets held in ETH"
    totalAssetsETH: BigDecimal!
}

type Transaction @entity {
    "Unique Identifier of the transaction called Transaction Hash = keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce))"
    id                  : ID!

    "Timestamp when the transaction was executed"
    stamp               : BigInt

    "Block on Ethereum"
    block               : BigInt

    "Transaction hash on Ethereum"
    hash                : Bytes

    "Status of the transaction"
    status              : TransactionStatus

    "Transaction hash on the Safe"
    txhash              : Bytes

    "Ether Amount (in WEI) included in the transaction - transferred from the wallet when the transaction is executed"
    value               : BigInt

    "Destination of the transaction"
    destination         : Bytes

    "Data of the transaction - smart contract input data bytecode - see https://lab.miguelmota.com/ethereum-input-data-decoder/example/"
    data                : Bytes

    "Signatures"
    signatures          : Bytes

    "Nonce"
    nonce               : BigInt

    "Operation"
    operation           : Operation

    "Estimated Gas that should be used for the Safe transaction."
    estimatedSafeTxGas  : BigInt

    "Estimated Gas costs for that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund)"
    estimatedBaseGas    : BigInt

    "gasPrice (in gasToken)"
    gasPrice            : BigInt

    "gasToken"
    gasToken            : Bytes

    "refundReceiver"
    refundReceiver      : Bytes

    "Amount paid as fee to refundReceiver"
    payment             : BigInt

    "Wallet parent"
    wallet              : Wallet! @derivedFrom(field: "transactions")
}

enum TransactionStatus {
    "Transaction was executed successfully"
    EXECUTED

    "Transaction failed during the execution"
    FAILED
}

enum Operation {
    CALL
    DELEGATE_CALL
}

type Token @entity {
  # token address
  id: ID!

  # mirrored from the smart contract
  symbol: String!
  name: String!
  decimals: BigInt!

  # used for other stats like marketcap
  totalSupply: BigInt!

  # derived prices
  derivedETH: BigDecimal
}